 [TestMethod]
 public void TestMathRound()
 {
     var a=Math.Round(6.5f);
     var b = Math.Round(11.5f);

     Assert.AreEqual(6, a);
     Assert.AreEqual(12, b);
 }
æ³¨æ„6.5 æ˜¯6 6.6 æ˜¯7  11.5 æ˜¯12

1. he result of Math.Round can differ depending on overloads and the rounding mode (MidpointRounding).
	â—‹ By default, Math.Round(double) uses MidpointRounding.ToEven ("bankerâ€™s rounding").
		Â§ 6.5 â†’ 6 (rounded to the nearest even)
		Â§ 11.5 â†’ 12 (rounded to the nearest even)
So the correct test is:

var a = Math.Round(6.5f);   // result: 6
var b = Math.Round(11.5f);  // result: 12
Assert.AreEqual(6, a);
Assert.AreEqual(12, b);
ğŸ‘‰ If you expected both 6.5 â†’ 7 and 11.5 â†’ 12, youâ€™d need to specify MidpointRounding.AwayFromZero:

var a = Math.Round(6.5f, MidpointRounding.AwayFromZero); // 7
var b = Math.Round(11.5f, MidpointRounding.AwayFromZero); // 12
Do you want me to explain why .NET uses bankerâ€™s rounding (ToEven) by default?

MidpointRounding ç­–ç•¥å¯¹æ¯”
æ•°å­—	ToEven (é»˜è®¤ï¼Œé“¶è¡Œå®¶èˆå…¥)	AwayFromZero (ä¼ ç»Ÿå››èˆäº”å…¥)	ToZero (è¶‹å‘é›¶)	ToNegativeInfinity (å‘ä¸‹å–æ•´)	ToPositiveInfinity (å‘ä¸Šå–æ•´)
1.5	2ï¼ˆå¶æ•°ï¼‰	2	1	1	2
2.5	2ï¼ˆå¶æ•°ï¼‰	3	2	2	3
3.5	4ï¼ˆå¶æ•°ï¼‰	4	3	3	4
4.5	4ï¼ˆå¶æ•°ï¼‰	5	4	4	5

MidpointRounding ç­–ç•¥å¯¹æ¯”
æ•°å­—	ToEven (é»˜è®¤ï¼Œé“¶è¡Œå®¶èˆå…¥)	AwayFromZero (ä¼ ç»Ÿå››èˆäº”å…¥)	ToZero (è¶‹å‘é›¶)	ToNegativeInfinity (å‘ä¸‹å–æ•´)	ToPositiveInfinity (å‘ä¸Šå–æ•´)
1.5	2ï¼ˆå¶æ•°ï¼‰	2	1	1	2
2.5	2ï¼ˆå¶æ•°ï¼‰	3	2	2	3
3.5	4ï¼ˆå¶æ•°ï¼‰	4	3	3	4
4.5	4ï¼ˆå¶æ•°ï¼‰	5	4	4	5

