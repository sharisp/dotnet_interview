下面我给你一个 **从基础到进阶** 的 C# 多态（Polymorphism）最清晰讲解 + 示例代码，让你快速掌握 **编译时多态** 和 **运行时多态** 的区别与用法。

---

# ✅ 1. 什么是多态？

多态 = **同一个方法名 / 接口 / 父类引用执行不同的实现**。

C# 的多态分两种：

## ✔️ **（1）编译时多态（静态）**

通过 **方法重载（Overload）** 实现。

## ✔️ **（2）运行时多态（动态）**

通过：

* `virtual`（父类可被重写）
* `override`（子类重写）
* `abstract`（必须重写）
* `interface`（实现接口）

实现 **同一个父类引用，调用不同子类方法**。

---

# ✅ 2. 编译时多态（方法重载）

```csharp
public class Calculator
{
    public int Add(int a, int b) => a + b;

    public double Add(double a, double b) => a + b; // 重载
}
```

同一个方法名 `Add`，根据参数不同调用不同实现。

---

# ✅ 3. 运行时多态（核心）

### 📌 父类 virtual — 子类 override

```csharp
public class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

public class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Dog barks");
    }
}

public class Cat : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Cat meows");
    }
}
```

### 使用：

```csharp
Animal a1 = new Dog();
Animal a2 = new Cat();

a1.Speak();  // Dog barks
a2.Speak();  // Cat meows
```

父类引用，但由于 override，会根据实际类型调用子类版本，这就是 **运行时多态的核心**。

---

# ✅ 4. 抽象类多态（abstract）

当父类定义方法但不提供实现：

```csharp
public abstract class Shape
{
    public abstract double Area();
}

public class Circle : Shape
{
    public double Radius { get; set; }
    public Circle(double r) => Radius = r;

    public override double Area() => Math.PI * Radius * Radius;
}
```

使用：

```csharp
Shape s = new Circle(5);
Console.WriteLine(s.Area()); // 78.5398...
```

---

# ✅ 5. 接口多态（interface）

更纯粹的多态：

```csharp
public interface IWorker
{
    void Work();
}

public class Teacher : IWorker
{
    public void Work() => Console.WriteLine("Teaching");
}

public class Developer : IWorker
{
    public void Work() => Console.WriteLine("Coding");
}
```

使用：

```csharp
IWorker w1 = new Teacher();
IWorker w2 = new Developer();

w1.Work(); // Teaching
w2.Work(); // Coding
```

---

# ✅ 6. override vs new（隐藏方法，不推荐）

如果你不想覆盖父类的 virtual 方法，而是隐藏它：

```csharp
public class Animal
{
    public virtual void Speak() => Console.WriteLine("Animal");
}

public class Dog : Animal
{
    public new void Speak() => Console.WriteLine("Dog");
}
```

使用：

```csharp
Animal a = new Dog();
a.Speak(); // Animal ❌（没有多态）
```

`new` 隐藏方法，不参与多态。所以 **一般只用 override**。

---

# 🔥 最经典的总结图

| 特性                     | 语法     | 发生时间 | 是否支持多态 |
| ---------------------- | ------ | ---- | ------ |
| **方法重载 Overload**      | 同名不同参数 | 编译时  | ❌      |
| **virtual + override** | 覆盖虚方法  | 运行时  | ✔️     |
| **abstract**           | 强制子类实现 | 运行时  | ✔️     |
| **interface**          | 实现接口方法 | 运行时  | ✔️     |
| **new 隐藏**             | 隐藏父类方法 | 运行时  | ❌（不建议） |

