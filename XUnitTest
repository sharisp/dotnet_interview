1ï¸âƒ£ é¡¹ç›®ç»“æ„ç¤ºä¾‹

MyApp/
  â”œâ”€ MyApp/
  â”‚    â”œâ”€ Services/
  â”‚    â”‚    â””â”€ OrderService.cs
  â”‚    â””â”€ Repositories/
  â”‚         â””â”€ IOrderRepository.cs
  â””â”€ MyApp.Tests/
       â”œâ”€ Unit/
       â”‚    â””â”€ OrderServiceTests.cs
       â””â”€ Integration/
            â””â”€ UserRepositoryTests.cs

2ï¸âƒ£ ç¤ºä¾‹ä»£ç 
2.1 æœåŠ¡ä¸æ¥å£

// IOrderRepository.cs
public interface IOrderRepository
{
    List<Order> GetOrders();
}
// OrderService.cs
public class OrderService
{
    private readonly IOrderRepository _repo;
    public OrderService(IOrderRepository repo) => _repo = repo;
public int CalculateTotal() => _repo.GetOrders().Sum(o => o.Amount);
}
// Order.cs
public class Order
{
    public int Amount { get; set; }
}

2.2 å•å…ƒæµ‹è¯•ï¼ˆUnit + Moqï¼‰

using Xunit;
using Moq;
using System.Collections.Generic;
namespace MyApp.Tests.Unit
{
    public class OrderServiceTests
    {
        [Fact]
        public void CalculateTotal_ReturnsCorrectSum()
        {
            var mockRepo = new Mock<IOrderRepository>();
            mockRepo.Setup(r => r.GetOrders()).Returns(new List<Order>
            {
                new Order { Amount = 100 },
                new Order { Amount = 50 }
            });
var service = new OrderService(mockRepo.Object);
            var total = service.CalculateTotal();
Assert.Equal(150, total);
// éªŒè¯ GetOrders æ˜¯å¦è°ƒç”¨
            mockRepo.Verify(r => r.GetOrders(), Times.Once);
        }
[Theory]
        [InlineData(1, 2, 3)]
        [InlineData(0, 0, 0)]
        [InlineData(-1, 1, 0)]
        public void Add_InlineDataExample(int a, int b, int expected)
        {
            var sum = a + b;
            Assert.Equal(expected, sum);
        }
    }
}

2.3 é›†æˆæµ‹è¯•ï¼ˆInMemory Databaseï¼‰

using Xunit;
using Microsoft.EntityFrameworkCore;
namespace MyApp.Tests.Integration
{
    // æ•°æ®åº“å®ä½“
    public class User
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
// DbContext
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}
        public DbSet<User> Users { get; set; }
    }
// Repository
    public class UserRepository
    {
        private readonly AppDbContext _context;
        public UserRepository(AppDbContext context) => _context = context;
        public void Add(User user) => _context.Users.Add(user);
        public User GetByName(string name) => _context.Users.FirstOrDefault(u => u.Name == name);
    }
public class UserRepositoryTests
    {
        private DbContextOptions<AppDbContext> _options;
public UserRepositoryTests()
        {
            // ä½¿ç”¨ InMemory DB
            _options = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: "TestDb")
                .Options;
        }
[Fact]
        public void CanAddAndRetrieveUser()
        {
            // Insert
            using (var context = new AppDbContext(_options))
            {
                var repo = new UserRepository(context);
                repo.Add(new User { Name = "Alice" });
                context.SaveChanges();
            }
// Retrieve
            using (var context = new AppDbContext(_options))
            {
                var repo = new UserRepository(context);
                var user = repo.GetByName("Alice");
                Assert.NotNull(user);
                Assert.Equal("Alice", user.Name);
            }
        }
    }
}

2.4 Fixtureï¼ˆå…±äº«èµ„æºï¼‰

using Xunit;
using Microsoft.EntityFrameworkCore;
public class DatabaseFixture : IDisposable
{
    public AppDbContext Context { get; private set; }
public DatabaseFixture()
    {
        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase("FixtureDb")
            .Options;
        Context = new AppDbContext(options);
    }
public void Dispose()
    {
        Context.Dispose();
    }
}
public class UserServiceTests : IClassFixture<DatabaseFixture>
{
    DatabaseFixture _fixture;
public UserServiceTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }
[Fact]
    public void CanAddUserUsingFixture()
    {
        _fixture.Context.Users.Add(new User { Name = "Bob" });
        _fixture.Context.SaveChanges();
var user = _fixture.Context.Users.FirstOrDefault(u => u.Name == "Bob");
        Assert.NotNull(user);
    }
}

3ï¸âƒ£ æ€»ç»“
	â€¢ å•å…ƒæµ‹è¯•ï¼šMoq + xUnit [Fact] / [Theory]
	â€¢ é›†æˆæµ‹è¯•ï¼šInMemory Database + Repository
	â€¢ Fixtureï¼šå…±äº«ä¸Šä¸‹æ–‡ / æ•°æ®åº“å®ä¾‹
	â€¢ ä¼˜åŠ¿ï¼šå¿«é€Ÿã€æ˜“ç»´æŠ¤ã€æ”¯æŒå‚æ•°åŒ–å’Œå¹¶è¡Œ
éå¸¸å¥½çš„é—®é¢˜ï¼ŒAndrew ğŸ‘
â€”â€”è¿™æ˜¯ä¸€ä¸ªé«˜çº§é¢è¯•å¸¸é—®ç‚¹ï¼šåœ¨ DDDï¼ˆDomain-Driven Designï¼‰ æ¶æ„ä¸­å¦‚ä½•ç¼–å†™æµ‹è¯•ã€‚
ä¸‹é¢æˆ‘ä¼šæ¸…æ™°åœ°å‘Šè¯‰ä½ åœ¨ DDD é¡¹ç›®ä¸­ æ¯ä¸€å±‚è¯¥å¦‚ä½•æµ‹è¯•ï¼Œå¹¶ç»™å‡ºå®é™… xUnit + Moq + InMemory ç¤ºä¾‹ä»£ç ç»“æ„ã€‚

ğŸ§© ä¸€ã€DDD é¡¹ç›®åˆ†å±‚ç»“æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰

MyApp/
â”œâ”€ Domain/
â”‚   â”œâ”€ Entities/
â”‚   â”‚   â””â”€ Order.cs
â”‚   â”œâ”€ ValueObjects/
â”‚   â”‚   â””â”€ Money.cs
â”‚   â”œâ”€ Events/
â”‚   â”‚   â””â”€ OrderCreatedEvent.cs
â”‚   â”œâ”€ Services/
â”‚   â”‚   â””â”€ OrderDomainService.cs
â”‚   â””â”€ Interfaces/
â”‚       â””â”€ IOrderRepository.cs
â”‚
â”œâ”€ Application/
â”‚   â”œâ”€ DTOs/
â”‚   â”œâ”€ Commands/
â”‚   â”œâ”€ Handlers/
â”‚   â”‚   â””â”€ CreateOrderHandler.cs
â”‚   â””â”€ Interfaces/
â”‚       â””â”€ IUnitOfWork.cs
â”‚
â”œâ”€ Infrastructure/
â”‚   â”œâ”€ Persistence/
â”‚   â”‚   â”œâ”€ AppDbContext.cs
â”‚   â”‚   â””â”€ EfOrderRepository.cs
â”‚   â””â”€ Services/
â”‚       â””â”€ EmailService.cs
â”‚
â””â”€ Tests/
    â”œâ”€ DomainTests/
    â”‚   â””â”€ OrderDomainServiceTests.cs
    â”œâ”€ ApplicationTests/
    â”‚   â””â”€ CreateOrderHandlerTests.cs
    â””â”€ IntegrationTests/
        â””â”€ EfOrderRepositoryTests.cs

ğŸ§ª äºŒã€DDD æµ‹è¯•åˆ†ç±»
æµ‹è¯•ç±»å‹	ç›®æ ‡	æŠ€æœ¯	ç¤ºä¾‹
âœ… é¢†åŸŸå±‚æµ‹è¯•	ä¸šåŠ¡è§„åˆ™ï¼ˆå®ä½“ã€å€¼å¯¹è±¡ã€é¢†åŸŸæœåŠ¡ï¼‰	çº¯å•å…ƒæµ‹è¯•ï¼ˆæ— å¤–éƒ¨ä¾èµ–ï¼‰	xUnit
âœ… åº”ç”¨å±‚æµ‹è¯•	ç”¨ä¾‹é€»è¾‘ï¼ˆCommand Handlerã€Application Serviceï¼‰	Mock Repository + Mock UnitOfWork	xUnit + Moq
âœ… åŸºç¡€è®¾æ–½å±‚æµ‹è¯•	ä»“å‚¨å®ç°ã€æ•°æ®åº“äº¤äº’	InMemory EF / TestContainer	xUnit + EF InMemory
âœ… é›†æˆæµ‹è¯•	å¤šå±‚äº¤äº’ï¼ˆHandler + Dbï¼‰	ä½¿ç”¨å®é™…DbContext	xUnit + WebApplicationFactory

ğŸ§  ä¸‰ã€é¢†åŸŸå±‚æµ‹è¯•ç¤ºä¾‹ï¼ˆDomainï¼‰
ğŸ“‚ Domain/Entities/Order.cs

public class Order
{
    public decimal TotalAmount { get; private set; }
    public bool IsPaid { get; private set; }
public void Pay(decimal amount)
    {
        if (amount < TotalAmount)
            throw new InvalidOperationException("Payment is insufficient.");
IsPaid = true;
    }
}
ğŸ“‚ Tests/DomainTests/OrderTests.cs

using Xunit;
public class OrderTests
{
    [Fact]
    public void Pay_Should_MarkOrderAsPaid_When_SufficientAmount()
    {
        var order = new Order();
        order.GetType().GetProperty("TotalAmount")!.SetValue(order, 100m);
order.Pay(100m);
Assert.True(order.IsPaid);
    }
[Fact]
    public void Pay_Should_Throw_When_AmountTooLow()
    {
        var order = new Order();
        order.GetType().GetProperty("TotalAmount")!.SetValue(order, 100m);
Assert.Throws<InvalidOperationException>(() => order.Pay(50m));
    }
}
ğŸ’¡ é‡ç‚¹ï¼š
	â€¢ çº¯é¢†åŸŸé€»è¾‘æµ‹è¯•ï¼Œä¸ä¾èµ–æ•°æ®åº“ã€‚
	â€¢ ç¡®ä¿ä¸šåŠ¡è§„åˆ™æ­£ç¡®ï¼Œæ¯”å¦‚é‡‘é¢æ ¡éªŒã€çŠ¶æ€å˜æ›´ã€‚

ğŸ§± å››ã€åº”ç”¨å±‚æµ‹è¯•ï¼ˆApplicationï¼‰
ğŸ“‚ Application/Handlers/CreateOrderHandler.cs

public class CreateOrderCommand
{
    public decimal TotalAmount { get; set; }
}
public class CreateOrderHandler
{
    private readonly IOrderRepository _repo;
    private readonly IUnitOfWork _uow;
public CreateOrderHandler(IOrderRepository repo, IUnitOfWork uow)
    {
        _repo = repo;
        _uow = uow;
    }
public async Task Handle(CreateOrderCommand cmd)
    {
        var order = new Order();
        order.GetType().GetProperty("TotalAmount")!.SetValue(order, cmd.TotalAmount);
_repo.Add(order);
        await _uow.SaveChangesAsync();
    }
}
ğŸ“‚ Tests/ApplicationTests/CreateOrderHandlerTests.cs

using Xunit;
using Moq;
using System.Threading.Tasks;
public class CreateOrderHandlerTests
{
    [Fact]
    public async Task Handle_Should_AddOrder_And_SaveChanges()
    {
        var mockRepo = new Mock<IOrderRepository>();
        var mockUow = new Mock<IUnitOfWork>();
var handler = new CreateOrderHandler(mockRepo.Object, mockUow.Object);
        var cmd = new CreateOrderCommand { TotalAmount = 100m };
await handler.Handle(cmd);
mockRepo.Verify(r => r.Add(It.IsAny<Order>()), Times.Once);
        mockUow.Verify(u => u.SaveChangesAsync(), Times.Once);
    }
}
ğŸ’¡ é‡ç‚¹ï¼š
	â€¢ æµ‹è¯•â€œç”¨ä¾‹æµç¨‹â€ï¼Œä¸å…³å¿ƒæ•°æ®åº“ã€‚
	â€¢ Mock Repository å’Œ UoWï¼ˆéš”ç¦»å¤–éƒ¨ä¾èµ–ï¼‰ã€‚

ğŸ§° äº”ã€åŸºç¡€è®¾æ–½å±‚æµ‹è¯•ï¼ˆInfrastructureï¼‰
ğŸ“‚ Infrastructure/Persistence/EfOrderRepository.cs

public class EfOrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    public EfOrderRepository(AppDbContext context) => _context = context;
public void Add(Order order) => _context.Orders.Add(order);
    public List<Order> GetAll() => _context.Orders.ToList();
}
ğŸ“‚ Tests/IntegrationTests/EfOrderRepositoryTests.cs

using Xunit;
using Microsoft.EntityFrameworkCore;
using System.Linq;
public class EfOrderRepositoryTests
{
    [Fact]
    public void Can_Add_And_Retrieve_Order()
    {
        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase("TestDb")
            .Options;
using var context = new AppDbContext(options);
        var repo = new EfOrderRepository(context);
var order = new Order();
        order.GetType().GetProperty("TotalAmount")!.SetValue(order, 200m);
        repo.Add(order);
        context.SaveChanges();
var result = repo.GetAll().First();
        Assert.Equal(200m, result.TotalAmount);
    }
}
ğŸ’¡ é‡ç‚¹ï¼š
	â€¢ ä½¿ç”¨ UseInMemoryDatabaseã€‚
	â€¢ æµ‹è¯•çœŸå® EF è¡Œä¸ºã€‚

ğŸ§© å…­ã€é›†æˆæµ‹è¯•ï¼ˆIntegrationï¼‰
å¦‚æœä½ æœ‰ API å±‚ï¼ˆå¦‚ ASP.NET Core Controller + MediatRï¼‰ï¼Œ
å¯ä½¿ç”¨ WebApplicationFactoryï¼š

using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Threading.Tasks;
using System.Net.Http.Json;
public class OrderApiTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public OrderApiTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
[Fact]
    public async Task POST_Order_Should_Return_201()
    {
        var response = await _client.PostAsJsonAsync("/api/orders", new { TotalAmount = 100 });
        response.EnsureSuccessStatusCode();
    }
}

âœ… ä¸ƒã€æ€»ç»“ï¼šDDD å„å±‚æµ‹è¯•ç­–ç•¥
å±‚çº§	æµ‹è¯•ç±»å‹	å·¥å…·	ä¾èµ–
Domain	çº¯å•å…ƒæµ‹è¯•	xUnit	æ— 
Application	Mock æµ‹è¯•	xUnit + Moq	ä»“å‚¨ã€UoW Mock
Infrastructure	é›†æˆæµ‹è¯•	xUnit + EF InMemory	EF DbContext
API å±‚	ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•	xUnit + WebApplicationFactory	çœŸå®HTTPè°ƒç”¨
XNUIT mock çš„ä½œç”¨ï¼Œæ˜¯mock æ¥å£å®ç°ä¹ˆ
ChatGPT said:
éå¸¸å¥½çš„é—®é¢˜ ğŸ‘ Andrewã€‚
ä½ ç†è§£å¾—å¾ˆå¯¹â€”â€”åœ¨ xUnit ä¸­ä½¿ç”¨ Moqï¼ˆæˆ–å…¶ä»– mocking æ¡†æ¶ï¼‰æœ€ä¸»è¦çš„ä½œç”¨ï¼Œå°±æ˜¯ â€œæ¨¡æ‹Ÿæ¥å£çš„å®ç°â€ï¼Œä½†å®ƒçš„ç”¨é€”ä¸æ­¢äºæ­¤ã€‚æˆ‘ä»¬æ¥ç³»ç»Ÿåœ°è®²æ¸…æ¥šğŸ‘‡

ğŸ§  ä¸€å¥è¯æ€»ç»“ï¼š
	Moq åœ¨ xUnitï¼ˆæˆ–ä»»ä½•å•å…ƒæµ‹è¯•æ¡†æ¶ï¼‰ä¸­çš„ä½œç”¨ï¼Œæ˜¯åˆ›å»ºâ€œå‡çš„ä¾èµ–å¯¹è±¡â€ï¼Œç”¨æ¥éš”ç¦»è¢«æµ‹ç±»ï¼Œåªæµ‹è¯•å®ƒè‡ªèº«é€»è¾‘ã€‚

âœ… å…¸å‹ç”¨é€”ï¼šMock æ¥å£å®ç°
ä¾‹å¦‚ï¼Œä½ çš„ UserService ä¾èµ–ä¸€ä¸ª IUserRepositoryï¼š

public interface IUserRepository
{
    User? GetByEmail(string email);
    void Add(User user);
}
public class UserService
{
    private readonly IUserRepository _repository;
public UserService(IUserRepository repository)
    {
        _repository = repository;
    }
public bool Register(string email, string name)
    {
        if (_repository.GetByEmail(email) != null)
            return false;
_repository.Add(new User(name, email));
        return true;
    }
}

ğŸš€ ä½¿ç”¨ Moq + xUnit è¿›è¡Œå•å…ƒæµ‹è¯•ï¼š

using Xunit;
using Moq;
public class UserServiceTests
{
    [Fact]
    public void Register_Should_Add_User_When_Not_Exists()
    {
        // Arrange
        var repoMock = new Mock<IUserRepository>();
        repoMock.Setup(r => r.GetByEmail("test@test.com")).Returns((User)null);
var service = new UserService(repoMock.Object);
// Act
        var result = service.Register("test@test.com", "Andrew");
// Assert
        Assert.True(result);
        repoMock.Verify(r => r.Add(It.IsAny<User>()), Times.Once);
    }
[Fact]
    public void Register_Should_Not_Add_User_When_Already_Exists()
    {
        // Arrange
        var repoMock = new Mock<IUserRepository>();
        repoMock.Setup(r => r.GetByEmail("test@test.com")).Returns(new User("Andrew", "test@test.com"));
var service = new UserService(repoMock.Object);
// Act
        var result = service.Register("test@test.com", "Andrew");
// Assert
        Assert.False(result);
        repoMock.Verify(r => r.Add(It.IsAny<User>()), Times.Never);
    }
}

ğŸ” Mock é™¤äº†æ¥å£è¿˜èƒ½æ¨¡æ‹Ÿä»€ä¹ˆï¼Ÿ
ç±»å‹	æ˜¯å¦å¯ Mock	è¯´æ˜
æ¥å£ (interface)	âœ…	æœ€å¸¸è§ï¼Œä¹Ÿæ˜¯æ¨èçš„æ–¹å¼
æŠ½è±¡ç±» (abstract class)	âœ…	å¯ä»¥ Mock å¹¶è®¾ç½®è™šæ‹Ÿæ–¹æ³•
æ™®é€šç±» (class)	âš ï¸ ä»…è™šæ‹Ÿæ–¹æ³•å¯ Mock	å¿…é¡»æ˜¯ virtual æ‰èƒ½è¢« Moq æ‹¦æˆª
é™æ€ç±»/é™æ€æ–¹æ³•	âŒ	æ— æ³•ç›´æ¥ Mockï¼ˆå¯ç”¨ wrapper æˆ–æ›¿ä»£åº“ï¼‰
æ•°æ®åº“ / å¤–éƒ¨ API	âœ…ï¼ˆé€šè¿‡æ¥å£åŒ…è£…ï¼‰	ä½¿ç”¨æ¥å£éš”ç¦»å¤–éƒ¨ä¾èµ–åå† Mock

ğŸ’¡ Mock çš„æ ¸å¿ƒä»·å€¼ï¼š
	1. éš”ç¦»ä¾èµ– â€”â€” ä¸è®¿é—®æ•°æ®åº“ã€ä¸å‘ HTTP è¯·æ±‚ã€‚
	2. æ§åˆ¶è¿”å›ç»“æœ â€”â€” è‡ªå®šä¹‰æ¥å£æ–¹æ³•çš„è¿”å›å€¼ã€‚
	3. éªŒè¯äº¤äº’ â€”â€” æ£€æŸ¥æŸæ–¹æ³•æ˜¯å¦è¢«è°ƒç”¨ï¼ˆVerifyï¼‰ã€‚
	4. æµ‹è¯•è¾¹ç•Œæƒ…å†µ â€”â€” æ¨¡æ‹Ÿå¼‚å¸¸ã€å»¶è¿Ÿã€ç©ºæ•°æ®ç­‰ã€‚

âœ… æ€»ç»“
åŠŸèƒ½	è¯´æ˜
Mock æ¥å£	âœ… æ ¸å¿ƒåŠŸèƒ½
æ§åˆ¶ä¾èµ–è¡Œä¸º	é€šè¿‡ .Setup()
éªŒè¯è°ƒç”¨è¡Œä¸º	é€šè¿‡ .Verify()
æ¨¡æ‹Ÿå¼‚å¸¸	.Throws()
ç»“åˆ xUnit	å®Œå…¨å…¼å®¹ï¼Œæ— é¢å¤–é…ç½®
