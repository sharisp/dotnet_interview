
1. 缓存穿透 (Cache Penetration)
定义
缓存穿透指的是查询一个根本不存在的数据。由于缓存中没有，数据库中也没有，所以每次请求都会穿过缓存直接到达数据库。当这种请求量非常大时，数据库的压力会急剧增加，甚至可能被压垮。
场景举例：
	• 恶意攻击者不断查询一个不存在的商品 ID。
	• 某个业务逻辑错误导致大量请求查询无效的用户 ID。
表现
	• 缓存命中率低。
	• 数据库压力异常升高，日志中出现大量查询未命中。
解决方案
	1. 布隆过滤器 (Bloom Filter)： 
		○ 原理： 在数据写入缓存和数据库之前，将所有可能存在的查询条件（例如所有商品 ID）哈希到一个巨大的位图中。当查询请求进来时，先通过布隆过滤器判断这个 ID 是否存在。如果布隆过滤器说“不存在”，那么这个数据就一定不存在，直接返回空，不再查询缓存和数据库。
		○ 优点： 空间效率高，对不存在的数据过滤效果显著，能有效拦截大量恶意请求。
		○ 缺点： 存在误判率（即布隆过滤器说“存在”，但实际可能不存在，这会导致一次不必要的数据库查询，但不会导致穿透），一旦加入就无法删除数据。
	2. 缓存空对象 (Cache Empty Objects)： 
		○ 原理： 当数据库查询返回的数据为空时，也把这个空结果（例如 null 或一个特定的空对象）缓存起来，并设置一个较短的过期时间。
		○ 优点： 实现简单，能够有效阻止对不存在数据的反复查询。
		○ 缺点： 会占用缓存空间，如果空数据量很大，可能导致内存浪费。同时，需要设置合适的过期时间，避免真实数据写入后，旧的空缓存仍存在。

2. 缓存雪崩 (Cache Avalanche)
定义
缓存雪崩是指在短时间内，大量缓存 Key 同时失效（或者缓存服务器宕机），导致所有请求都直接落到数据库上，从而导致数据库压力骤增，甚至崩溃，就像雪崩一样。
场景举例：
	• 大批商品在同一时间点过期。
	• 缓存服务整体宕机。
表现
	• 在某个时间点之后，缓存命中率突然断崖式下降。
	• 数据库 CPU 使用率、连接数、I/O 等指标瞬间飙升。
	• 系统响应变慢或直接崩溃。
解决方案
	1. 设置不同的过期时间 (Random Expiration Time)： 
		○ 原理： 给缓存中的数据设置随机的过期时间，而不是统一的过期时间。例如，可以在基础过期时间上加上一个随机值（expireTime = baseTime + random(0, N)）。
		○ 优点： 使得缓存失效的时间点错开，避免了大量 Key 同时过期。
	2. 缓存高可用 (High Availability for Cache): 
		○ 原理： 部署缓存集群，使用主从复制、分片等技术，确保缓存服务的稳定性和可用性。即使部分节点故障，整个缓存系统也能继续对外提供服务。
		○ 优点： 从根本上避免了缓存服务器整体宕机导致的雪崩。
	3. 熔断与限流 (Circuit Breaker and Rate Limiting)： 
		○ 原理： 当数据库压力达到阈值时，触发熔断机制，暂停部分或所有对数据库的访问，直接返回错误或默认值。同时，对进入系统的请求进行限流，防止过高的并发量直接打垮数据库。
		○ 优点： 保护数据库不被击垮，给系统争取恢复时间。
		○ 缺点： 会导致部分用户请求失败，影响用户体验。
	4. 多级缓存 (Multi-Level Caching)： 
		○ 原理： 除了分布式缓存外，还可以引入本地缓存（如 Caffeine, Guava Cache）或者 CDN 缓存。当一级缓存失效时，请求可以先尝试二级缓存，减少直接访问数据库的概率。

3. 缓存击穿 (Cache Breakdown)
定义
缓存击穿是指某个热门的 Key 在缓存中过期的那一瞬间，同时有大量的并发请求去查询这个 Key。由于缓存已经过期，这些请求都会击穿缓存，直接查询数据库。如果这个 Key 是一个热点数据，并且查询量巨大，那么数据库可能会在短时间内面临巨大的压力。
场景举例：
	• 某个新闻头条、明星微博在缓存过期时被大量用户同时访问。
	• 秒杀活动中，某个商品在缓存过期时被瞬间抢购。
表现
	• 某个或少数几个 Key 的命中率骤降。
	• 数据库针对特定 Key 的查询量瞬间飙升，可能导致慢查询或死锁。
解决方案
	1. 互斥锁 (Mutex Lock) 或分布式锁 (Distributed Lock)： 
		○ 原理： 当缓存失效后，第一个请求去查询数据库时，它会获得一个锁（可以是本地锁或分布式锁）。其他并发请求在获取锁失败后，会选择等待或者直接返回旧的缓存数据（如果有的话）。获得锁的请求查询到数据后，会将其写入缓存，并释放锁。
		○ 优点： 有效防止了大量请求同时击穿数据库。
		○ 缺点： 
			§ 死锁风险： 如果获取锁的请求出现异常未能释放锁，可能导致后续请求一直阻塞。
			§ 性能开销： 锁机制本身会带来一定的性能损耗，在高并发下可能导致吞吐量下降。
			§ 等待时间： 阻塞的请求会增加响应时间。
	2. 设置永不过期 (Never Expire) 或逻辑过期： 
		○ 原理： 
			§ 物理永不过期： 将热点数据在缓存中设置为永不过期。
			§ 逻辑过期： 缓存数据中除了存储实际内容，还额外存储一个逻辑过期时间字段。当读取数据时，如果发现逻辑过期时间已到，不立即删除缓存，而是后台异步地启动一个线程去刷新缓存，同时继续返回旧的（但可能已逻辑过期）数据。
		○ 优点： 避免了 Key 的物理失效，减少了击穿的可能性。
		○ 缺点： 
			§ 数据一致性： 逻辑过期期间返回的是旧数据，可能存在短时间的数据不一致。
			§ 内存占用： 永不过期会一直占用内存，除非手动清除。
			§ 复杂性： 逻辑过期需要额外的后台刷新机制，增加了实现复杂性。
